esphome:
  name: plant-indoor
  friendly_name: "Indoor Plant Monitor"
  min_version: 2024.6.0  # Compatible with older Dashboard versions
  on_boot:
    priority: -100
    then:
      - delay: 2s  # Let WiFi stabilize
      - component.update: soil_moisture  # Force moisture reading first
      - delay: 3s  # Wait for reading to process
      - component.update: moisture_percentage
      - component.update: plant_status
      - delay: 8s  # Longer wait for time sync
      - if:
          condition:
            lambda: 'return id(sntp_time).now().is_valid();'
          then:
            - component.update: plant_last_checked
          else:
            - logger.log: "Time not yet synchronized, skipping timestamp update"
            - delay: 5s  # Wait a bit more and try again
            - if:
                condition:
                  lambda: 'return id(sntp_time).now().is_valid();'
                then:
                  - component.update: plant_last_checked
      - delay: 2s  # Ensure all data is sent
      # - deep_sleep.enter: deep_sleep_ctrl  # Temporarily disabled for setup

esp32:
  board: esp32dev
  framework:
    type: arduino

# Enable logging
logger:
 # level: INFO  # Reduced from DEBUG for battery savings
 # baud_rate: 115200
  level: ERROR
  baud_rate: 0

# Disable onboard LED to save power
# status_led:

# WiFi Configuration
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  manual_ip:
    static_ip: !secret static_ip_plant
    gateway: !secret gateway
    subnet: !secret subnet
  # Power save mode for battery optimization
  power_save_mode: light

# MQTT Configuration for Home Assistant
mqtt:
  broker: !secret ha_broker
  username: mqttuser
  password: !secret mqtt_pass
  discovery: true  # Enable auto-discovery for dashboard visibility
  discovery_prefix: homeassistant
  discovery_retain: true  # Retain discovery messages
  reboot_timeout: 0s
  topic_prefix: plant-indoor

# API Configuration for Home Assistant
api:
  encryption:
    key: L9mF4pN6kS2rE8wH1qX5TcB3GjM7YvA0ZnI4DhP9OeL=

ota:
  platform: esphome
  password: !secret ota_password

deep_sleep:
  id: deep_sleep_ctrl
  sleep_duration: 6h  # Optimal for Monstera - checks 4x daily
  wakeup_pin: GPIO33  # Optional: use a button for manual wake

# Configure the soil moisture sensor
sensor:
  - platform: adc
    pin: GPIO35  # ADC1 pin - works reliably with WiFi
    name: "Soil Moisture Raw"
    id: soil_moisture
    unit_of_measurement: "V"
    accuracy_decimals: 3
    update_interval: 2s  # Faster updates during wake period
    expire_after: 7h  # Keep value for longer than sleep cycle
    force_update: true  # Always send updates even if value unchanged
    availability:  # Disable availability tracking for battery device
      topic: none
    attenuation: 11db  # For measuring up to ~3.6V on the pin
    filters:
      - lambda: |-
          if (x < 0.1) {
            return NAN;  // Filter out obviously wrong readings
          }
          return x;
      - sliding_window_moving_average:
          window_size: 5  # Smooth out sensor fluctuations
          send_every: 5
      - filter_out: nan
      - delta: 0.02  # Only send if change is > 0.02V
    state_class: measurement
    internal: true  # Hide raw voltage, show percentage instead
    on_value:
      - component.update: moisture_percentage  # Trigger percentage calculation
      - component.update: plant_status         # Trigger status calculation

  - platform: template
    name: "Soil Moisture"
    id: moisture_percentage
    unit_of_measurement: "%"
    accuracy_decimals: 1
    expire_after: 7h  # Keep value for longer than sleep cycle
    force_update: true  # Always send updates even if value unchanged
    availability:  # Disable availability tracking for battery device
      topic: none
    lambda: |-
      float voltage = id(soil_moisture).state;
      if (isnan(voltage)) return NAN;
      
      // Moisture sensor calibration (adjust based on your sensor)
      // Dry soil: ~3.0V = 0%
      // Wet soil: ~1.2V = 100%
      // Linear mapping between these points
      float dry_voltage = 3.0;    // Adjust: voltage when sensor is in dry soil
      float wet_voltage = 1.2;    // Adjust: voltage when sensor is in wet soil
      
      if (voltage >= dry_voltage) return 0.0;   // Completely dry
      if (voltage <= wet_voltage) return 100.0; // Completely wet
      
      // Linear interpolation
      float moisture = ((dry_voltage - voltage) / (dry_voltage - wet_voltage)) * 100.0;
      return moisture;
    filters:
      - filter_out: nan
      - delta: 1.0  # Only send if change is > 1%
    update_interval: never  # Only update when triggered
    state_class: measurement
    device_class: humidity
    icon: "mdi:water-percent"

  - platform: template
    name: "Plant Status"
    id: plant_status
    accuracy_decimals: 0
    expire_after: 7h  # Keep value for longer than sleep cycle
    force_update: true  # Always send updates even if value unchanged
    availability:  # Disable availability tracking for battery device
      topic: none
    lambda: |-
      float moisture = id(moisture_percentage).state;
      if (isnan(moisture)) return NAN;
      
      // Return status codes: 3=Optimal, 2=Good, 1=Dry, 0=Critical
      // Monstera-specific thresholds: likes to dry out between waterings
      if (moisture >= 50) return 3;  // Optimal (50-100% - well hydrated)
      if (moisture >= 30) return 2;  // Good (30-50% - getting drier, still OK)
      if (moisture >= 15) return 1;  // Dry (15-30% - needs water soon)
      return 0;  // Critical (<15% - water immediately!)
    filters:
      - filter_out: nan
    update_interval: never  # Only update when triggered

# Optional: Temperature sensor (if you have DHT22/BME280)
# Uncomment and connect to GPIO pin if available
#  - platform: dht
#    pin: GPIO4
#    model: DHT22
#    temperature:
#      name: "Plant Temperature"
#      expire_after: 75min
#      availability:
#        topic: none
#    humidity:
#      name: "Air Humidity"
#      expire_after: 75min
#      availability:
#        topic: none
#    update_interval: 5s

# Binary sensors for plant care alerts
binary_sensor:
  - platform: status
    name: "Plant Monitor Status"
    availability:  # Disable availability tracking for battery device
      topic: none

  - platform: template
    name: "Plant Needs Water"
    availability:  # Disable availability tracking for battery device
      topic: none
    lambda: |-
      float moisture = id(moisture_percentage).state;
      if (isnan(moisture)) return false;
      return moisture < 25;  // Monstera needs water threshold
    filters:
      - delayed_on: 30s  # Avoid false alarms from sensor spikes
    device_class: problem
    icon: "mdi:water-alert"

  - platform: template
    name: "Plant Critical Dry"
    availability:  # Disable availability tracking for battery device
      topic: none
    lambda: |-
      float moisture = id(moisture_percentage).state;
      if (isnan(moisture)) return false;
      return moisture < 12;  // Monstera critical dry threshold
    filters:
      - delayed_on: 60s  # Longer delay for critical alerts
    device_class: problem
    icon: "mdi:alert-circle"

# Time sync for last checked timestamp
time:
  - platform: sntp
    id: sntp_time
    timezone: Australia/Melbourne  # Melbourne, Australia timezone
    servers:
      - 0.pool.ntp.org
      - 1.pool.ntp.org
      - time.nist.gov
    on_time_sync:
      - logger.log: "Time synchronized with NTP server"
      - component.update: plant_last_checked

text_sensor:
  - platform: template
    name: "Plant Last Checked"
    id: plant_last_checked
    availability:  # Disable availability tracking for battery device
      topic: none
    lambda: |-
      auto time = id(sntp_time).now();
      if (!time.is_valid()) {
        return {"Time not synced"};
      }
      char str[30];
      time_t curr_time = time.timestamp;
      strftime(str, sizeof(str), "%H:%M %d/%m", localtime(&curr_time));
      return { str };
    update_interval: never  # Only update when triggered or on time sync

  - platform: template
    name: "Plant Status Text"
    availability:  # Disable availability tracking for battery device
      topic: none
    lambda: |-
      float status = id(plant_status).state;
      if (isnan(status)) return {"Unknown"};
      
      if (status >= 3) return {"Optimal"};
      if (status >= 2) return {"Good"};
      if (status >= 1) return {"Needs Water"};
      return {"Critical - Water Now!"};
    update_interval: 60s
    icon: "mdi:flower"

# Web Server for device access
web_server:
  port: 80
  auth:
    username: admin
    password: !secret ota_password  # Reuse OTA password for simplicity

# captive_portal:
