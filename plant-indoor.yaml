esphome:
  name: plant-indoor
  friendly_name: "Indoor Plant Monitor"
  min_version: 2024.6.0  # Compatible with older Dashboard versions
  on_boot:
    priority: -100
    then:
      - delay: 10s  # Let WiFi and all components fully initialize
      - logger.log: "Plant monitor starting up..."
      - logger.log: "Waiting for MQTT connection and commands (Stay Awake Mode can be toggled ON now)..."
      - delay: 15s  # Wait for MQTT to connect and receive any retained commands
      # MQTT on_message subscription will automatically handle Stay Awake Mode commands
      # If no MQTT command received, default to ON (restore_mode: ALWAYS_ON)
      - switch.turn_on: stay_awake_switch  # Default to stay awake mode ON (can be overridden by MQTT)
      - component.update: soil_moisture  # Force moisture reading first
      - delay: 3s  # Wait for reading to process
      - component.update: moisture_percentage
      - component.update: plant_status
      - delay: 45s  # Longer wait for time sync (NTP can take 30-45 seconds, especially on first boot)
      - logger.log: "Checking time sync status..."
      - if:
          condition:
            lambda: 'return id(sntp_time).now().is_valid();'
          then:
            - logger.log: "✅ Time is synced"
          else:
            - logger.log: "❌ Time NOT synced yet - will retry"
            - delay: 10s  # Wait a bit more and try again
            - if:
                condition:
                  lambda: 'return id(sntp_time).now().is_valid();'
                then:
                  - logger.log: "✅ Time synced on retry"
                else:
                  - logger.log: "❌ Time still not synced - check NTP connectivity"
      - logger.log: "Boot sequence complete - device ready"

esp32:
  board: esp32dev
  framework:
    type: arduino

# Enable logging
logger:
  level: INFO  # INFO level to reduce CPU usage and prevent overheating
  baud_rate: 115200  # Enable UART logging for debugging

# Disable onboard LED to save power
# status_led:

# WiFi Configuration
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  # Using static IP now that device is working
  manual_ip:
    static_ip: !secret static_ip_plant
    gateway: !secret gateway
    subnet: !secret subnet
  fast_connect: true  # Skip full scan, connect faster
  power_save_mode: light  # Light power save to reduce heat while maintaining connection
  # Fallback hotspot (captive portal) for WiFi troubleshooting
  ap:
    ssid: "Plant-Indoor Fallback"
    password: !secret ota_password
  # Increase reboot timeout for slow WiFi connections
  reboot_timeout: 10min

# MQTT Configuration for Home Assistant
mqtt:
  broker: !secret ha_broker
  username: !secret mqtt_user
  password: !secret mqtt_pass
  discovery: true  # Enable auto-discovery for dashboard visibility
  discovery_prefix: homeassistant
  discovery_retain: true  # Retain discovery messages
  reboot_timeout: 0s
  topic_prefix: plant-indoor
  keepalive: 3600s  # 1 hour - minimal keepalive for battery optimization (device reconnects after deep sleep)
  birth_message:
    topic: plant-indoor/status
    payload: online
    retain: true
  # will_message removed - allows sensors to show last known values during deep sleep
  # Device will reconnect and send "online" when it wakes up
  # Subscribe to Stay Awake Mode command topic - allows control even when device is sleeping
  on_message:
    - topic: plant-indoor/stay_awake/command
      payload: "ON"
      then:
        - switch.turn_on: stay_awake_switch
        - logger.log: "Stay Awake Mode turned ON via MQTT command"
    - topic: plant-indoor/stay_awake/command
      payload: "OFF"
      then:
        - switch.turn_off: stay_awake_switch
        - logger.log: "Stay Awake Mode turned OFF via MQTT command"

# API Configuration for Home Assistant
api:
  encryption:
    key: L9mF4pN6kS2rE8wH1qX5TcB3GjM7YvA0ZnI4DhP9OeL=

ota:
  platform: esphome
  password: !secret ota_password

# Deep sleep for power saving - wakes at 6-hour intervals (00:00, 06:00, 12:00, 18:00)
# Sleep duration is calculated dynamically to wake at predictable times
deep_sleep:
  id: deep_sleep_ctrl
  sleep_duration: 6h  # Default duration (overridden by dynamic calculation to wake at 6h intervals)
  # wakeup_pin: GPIO33  # Optional: use a button for manual wake
  # Deep sleep will be controlled by stay_awake_switch

# Configure the soil moisture sensor
sensor:
  - platform: adc
    pin: GPIO35  # ADC1 pin - works reliably with WiFi
    name: "Soil Moisture Raw"
    id: soil_moisture
    unit_of_measurement: "V"
    accuracy_decimals: 3
    update_interval: 5min  # Battery optimized - updates every 5 minutes when awake
    # In always-on mode, we can update more frequently for better responsiveness
    expire_after: 8h  # Longer than sleep cycle (6h) - keeps values visible during sleep
    force_update: true  # Always send updates even if value unchanged
    attenuation: 12db  # For measuring up to ~3.6V on the pin
    filters:
      - lambda: |-
          if (x < 0.1) {
            return 1.5;  // Return default value instead of NAN to keep sensor available
          }
          return x;
      - sliding_window_moving_average:
          window_size: 5  # Smooth out sensor fluctuations
          send_every: 5
      - delta: 0.02  # Only send if change is > 0.02V
    state_class: measurement
    internal: true  # Hide raw voltage, show percentage instead
    on_value:
      - component.update: moisture_percentage  # Trigger percentage calculation
      - component.update: plant_status         # Trigger status calculation

  - platform: template
    name: "Soil Moisture"
    id: moisture_percentage
    unit_of_measurement: "%"
    accuracy_decimals: 1
    expire_after: 8h  # Longer than sleep cycle (6h) - keeps values visible during sleep
    force_update: true  # Always send updates even if value unchanged
    lambda: |-
      float voltage = id(soil_moisture).state;
      if (isnan(voltage)) return 50.0;  // Return default 50% instead of NAN
      
      // Moisture sensor calibration (adjust based on your sensor)
      // Dry soil: ~3.0V = 0%
      // Wet soil: ~1.2V = 100%
      // Linear mapping between these points
      float dry_voltage = 3.0;    // Adjust: voltage when sensor is in dry soil
      float wet_voltage = 1.2;    // Adjust: voltage when sensor is in wet soil
      
      if (voltage >= dry_voltage) return 0.0;   // Completely dry
      if (voltage <= wet_voltage) return 100.0; // Completely wet
      
      // Linear interpolation
      float moisture = ((dry_voltage - voltage) / (dry_voltage - wet_voltage)) * 100.0;
      return moisture;
    filters:
      - filter_out: nan
      - delta: 1.0  # Only send if change is > 1%
    update_interval: 5min  # Battery optimized - updates every 5 minutes when awake
    state_class: measurement
    device_class: humidity
    icon: "mdi:water-percent"

  # WiFi signal strength sensor - helps diagnose connection issues
  - platform: wifi_signal
    name: "Plant Monitor WiFi Signal"
    update_interval: 60s
    entity_category: diagnostic
    unit_of_measurement: "dBm"
    accuracy_decimals: 0

  # Stay Awake Control sensor removed - switch now works independently

  - platform: template
    name: "Plant Status"
    id: plant_status
    accuracy_decimals: 0
    expire_after: 8h  # Longer than sleep cycle (6h) - keeps values visible during sleep
    force_update: true  # Always send updates even if value unchanged
    lambda: |-
      float moisture = id(moisture_percentage).state;
      if (isnan(moisture)) return 2;  // Return default "Good" status instead of NAN
      
      // Return status codes: 3=Optimal, 2=Good, 1=Dry, 0=Critical
      // Monstera-specific thresholds: likes to dry out between waterings
      if (moisture >= 50) return 3;  // Optimal (50-100% - well hydrated)
      if (moisture >= 30) return 2;  // Good (30-50% - getting drier, still OK)
      if (moisture >= 15) return 1;  // Dry (15-30% - needs water soon)
      return 0;  // Critical (<15% - water immediately!)
    filters:
      - filter_out: nan
    update_interval: 5min  # Battery optimized - updates every 5 minutes when awake

# Optional: Temperature sensor (if you have DHT22/BME280)
# Uncomment and connect to GPIO pin if available
#  - platform: dht
#    pin: GPIO4
#    model: DHT22
#    temperature:
#      name: "Plant Temperature"
#      expire_after: 75min
#      availability:
#        topic: none
#    humidity:
#      name: "Air Humidity"
#      expire_after: 75min
#      availability:
#        topic: none
#    update_interval: 5s

# Switch to control deep sleep behavior
switch:
  - platform: template
    name: "Stay Awake Mode"
    id: stay_awake_switch
    optimistic: true
    restore_mode: ALWAYS_ON  # Always start with stay awake mode ON
    icon: "mdi:power"
    # availability removed - allows switch to show last state during deep sleep
    # MQTT commands are handled via on_message subscription below
    turn_on_action:
      - logger.log: "Stay awake mode enabled - device will not sleep"
      - mqtt.publish:
          topic: plant-indoor/stay_awake/state
          payload: "ON"
          retain: true
    turn_off_action:
      - logger.log: "Stay awake mode disabled - entering deep sleep"
      - mqtt.publish:
          topic: plant-indoor/stay_awake/state
          payload: "OFF"
          retain: true
      - delay: 5s  # Give time for final data transmission
      # Calculate sleep duration to wake at next 6-hour interval (00:00, 06:00, 12:00, 18:00)
      - lambda: |-
          auto time = id(sntp_time).now();
          if (time.is_valid()) {
            int current_hour = time.hour;
            int current_minute = time.minute;
            int current_second = time.second;
            // Find next 6-hour interval (00:00, 06:00, 12:00, 18:00)
            int next_interval_hour = ((current_hour / 6) + 1) * 6;
            if (next_interval_hour >= 24) next_interval_hour = 0;  // Wrap to midnight
            
            // Calculate hours and minutes until next interval
            int hours_until = next_interval_hour - current_hour;
            if (hours_until <= 0) hours_until += 24;  // If past the hour, go to next day
            int minutes_until = 60 - current_minute;
            if (minutes_until == 60) {
              minutes_until = 0;
              hours_until--;
            }
            int seconds_until = 60 - current_second;
            if (seconds_until == 60) seconds_until = 0;
            
            // Total seconds until next interval
            int total_seconds = (hours_until * 3600) + (minutes_until * 60) + seconds_until;
            // Minimum 1 hour, maximum 6 hours
            if (total_seconds < 3600) total_seconds = 21600;  // If less than 1h, sleep until next interval
            if (total_seconds > 21600) total_seconds = 21600;  // Cap at 6 hours
            
            id(deep_sleep_ctrl).set_sleep_duration(total_seconds * 1000ULL);  // Convert to milliseconds
            ESP_LOGI("deep_sleep", "Sleeping for %d hours %d minutes until next 6h interval (%02d:00)", 
                     hours_until, minutes_until, next_interval_hour);
          } else {
            // If time not synced, use 6 hours default
            id(deep_sleep_ctrl).set_sleep_duration(21600000ULL);
            ESP_LOGI("deep_sleep", "Time not synced - sleeping for 6 hours");
          }
      - logger.log: "Entering deep sleep - will wake at next 6-hour interval"
      - deep_sleep.enter: deep_sleep_ctrl

# Binary sensors for plant care alerts
binary_sensor:
  - platform: status
    name: "Plant Monitor Status"
    # availability removed - allows switch to show last state during deep sleep

  - platform: template
    name: "Plant Needs Water"
    # Disable availability tracking - keeps last known state visible when device is unavailable
    availability:
      topic: none
    lambda: |-
      float moisture = id(moisture_percentage).state;
      if (isnan(moisture)) return false;
      return moisture < 25;  // Monstera needs water threshold
    filters:
      - delayed_on: 30s  # Avoid false alarms from sensor spikes
    device_class: problem
    icon: "mdi:water-alert"

  - platform: template
    name: "Plant Critical Dry"
    # Disable availability tracking - keeps last known state visible when device is unavailable
    availability:
      topic: none
    lambda: |-
      float moisture = id(moisture_percentage).state;
      if (isnan(moisture)) return false;
      return moisture < 12;  // Monstera critical dry threshold
    filters:
      - delayed_on: 60s  # Longer delay for critical alerts
    device_class: problem
    icon: "mdi:alert-circle"

# Time sync for time-based automation
time:
  - platform: sntp
    id: sntp_time
    timezone: Australia/Melbourne  # Melbourne, Australia timezone
    servers:
      - time.google.com  # Google's reliable NTP servers (most reliable)
      - time.cloudflare.com  # Cloudflare's NTP servers (fast and reliable)
      - 0.au.pool.ntp.org  # Australian NTP pool - closer servers for faster sync
    on_time_sync:
      - logger.log: "✅ Time synchronized with NTP server"

text_sensor:
  - platform: template
    name: "Plant Status Text"
    # availability removed - allows switch to show last state during deep sleep
    lambda: |-
      float status = id(plant_status).state;
      if (isnan(status)) return {"Unknown"};
      
      if (status >= 3) return {"Optimal"};
      if (status >= 2) return {"Good"};
      if (status >= 1) return {"Needs Water"};
      return {"Critical - Water Now!"};
    update_interval: 60s
    icon: "mdi:flower"

  - platform: template
    name: "Device Mode"
    # availability removed - allows switch to show last state during deep sleep
    lambda: |-
      if (id(stay_awake_switch).state) {
        return {"Stay Awake"};
      } else {
        return {"Deep Sleep"};
      }
    update_interval: 5min  # Battery optimized
    icon: "mdi:power"

# Web Server for device access
web_server:
  port: 80
  auth:
    username: admin
    password: !secret ota_password  # Reuse OTA password for simplicity

# captive_portal:

# Periodic updates when awake - only runs if stay awake mode is ON
# When deep sleep is active, device wakes every 6h and sends data automatically
interval:
  # Sensor updates - runs every 5 minutes when awake
  - interval: 5min
    then:
      - if:
          condition:
            lambda: 'return id(stay_awake_switch).state;'
          then:
            - logger.log: "Stay awake mode - periodic sensor update"
            - component.update: soil_moisture
            - delay: 2s
            - component.update: moisture_percentage
            - component.update: plant_status
