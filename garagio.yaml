esphome:
  name: garage-door-sensor
  friendly_name: "Garage Door"
  on_boot:
    priority: -100
    then:
      - delay: 15s  # Let WiFi and components initialize
      - logger.log: "Garage door sensor starting up..."
      - switch.turn_on: stay_awake_switch  # Default to stay awake mode ON on boot
      - component.update: garage_distance  # Force initial reading (binary sensor updates automatically)
      - delay: 2s
      - logger.log: "Boot sequence complete - waiting for time sync..."
      - delay: 45s  # Wait longer for time sync (NTP can take 30-45 seconds, especially on first boot)
      - logger.log: "Checking time sync status..."
      - if:
          condition:
            lambda: 'return id(sntp_time).now().is_valid();'
          then:
            - logger.log: "✅ Time is synced"
          else:
            - logger.log: "❌ Time NOT synced yet - will retry"
            - delay: 10s
            - if:
                condition:
                  lambda: 'return id(sntp_time).now().is_valid();'
                then:
                  - logger.log: "✅ Time synced on retry"
                else:
                  - logger.log: "❌ Time still not synced - check NTP connectivity"
      # Always send update after wake from deep sleep to keep sensors available

esp32:
  board: esp32dev
  framework:
    type: arduino

# Enable logging
logger:
  level: DEBUG  # DEBUG level temporarily to troubleshoot time sync
  baud_rate: 115200

# Global variable to track WiFi disconnection duration
globals:
  - id: wifi_disconnected_count
    type: int
    restore_value: false
    initial_value: '0'

# WiFi Configuration - Optimized for weak signal in garage
# IMPORTANT: ESP32 only supports 2.4GHz WiFi (not 5GHz)
# Google Nest WiFi uses a single SSID for both 2.4GHz and 5GHz
# ESP32 will automatically connect to 2.4GHz when connecting to this SSID
wifi:
  id: wifi_main  # ID for WiFi component to allow reconnection control
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  manual_ip:
    static_ip: !secret static_ip_garage   
    gateway: !secret gateway
    subnet: !secret subnet
  # Disable fast_connect for weak signals - allows full scan to find best signal
  fast_connect: false
  # Disable power save mode for maximum signal strength in garage
  power_save_mode: none
  # Output power: maximum for better range (can be 0-20.5 dBm, default is usually 19.5)
  output_power: 20.5dBm
  # Fallback hotspot for WiFi troubleshooting (activates if can't connect after 2min)
  ap:
    ssid: "Garage-Door-Fallback"
    password: !secret ota_password
  # Shorter timeout since we have better reconnection handling below
  reboot_timeout: 10min  # Reboot if can't connect after 10min (recovery mechanisms will try first)
  # Connection event logging for diagnostics
  on_connect:
    - logger.log: "WiFi connected successfully"
    # Reset disconnection counter when WiFi connects
    - lambda: |-
        id(wifi_disconnected_count) = 0;
  on_disconnect:
    - logger.log: "WiFi disconnected - ESPHome will attempt automatic reconnection"

# MQTT Configuration for Home Assistant
mqtt:
  broker: !secret ha_broker
  username: !secret mqtt_user
  password: !secret mqtt_pass
  discovery: true  # Enable auto-discovery for MQTT control (allows switch control even when device is sleeping)
  discovery_prefix: homeassistant
  discovery_retain: true
  reboot_timeout: 0s
  topic_prefix: garage-door-sensor
  keepalive: 3600s  # 1 hour - minimal keepalive for battery/heat optimization
  birth_message:
    topic: garage-door-sensor/status
    payload: online
    retain: true
  # will_message removed - allows sensors to show last known values during deep sleep
  # Subscribe to Stay Awake Mode command topic - allows control even when device is sleeping
  on_message:
    - topic: garage-door-sensor/stay_awake/command
      payload: "ON"
      then:
        - switch.turn_on: stay_awake_switch
        - logger.log: "Stay Awake Mode turned ON via MQTT command"
    - topic: garage-door-sensor/stay_awake/command
      payload: "OFF"
      then:
        - switch.turn_off: stay_awake_switch
        - logger.log: "Stay Awake Mode turned OFF via MQTT command"

# API Configuration for Home Assistant (needed for OTA updates)
# Keep API enabled but MQTT will be primary for control (works during deep sleep)
api:
  encryption:
    key: !secret encryption_key_garage

ota:
  platform: esphome
  password: !secret ota_password

# Deep sleep for power/heat management - OPTIONAL if device is powered
# If powered (not battery), deep sleep is mainly for heat management
# Only enters deep sleep when "Stay Awake Mode" is OFF
# When "Stay Awake Mode" is ON, device runs continuously (no sleep, no WiFi disconnects)
# ESP32 can safely run continuously for 12+ hours - designed for continuous operation
# Sleep duration is calculated dynamically to wake at the top of each hour (:00)
deep_sleep:
  id: deep_sleep_ctrl
  sleep_duration: 1h  # Default duration (overridden by dynamic calculation to wake at :00)
  # wakeup_pin: GPIO33  # Optional: use a button for instant wake

# Configure the HC-SR04 ultrasonic sensor
sensor:
  - platform: ultrasonic
    trigger_pin: GPIO14
    echo_pin: GPIO13
    name: "Garage Door Distance"
    id: garage_distance
    unit_of_measurement: "m"
    filters:
      - lambda: |-
          ESP_LOGD("garage_sensor", "Raw distance reading: %.3f meters", x);
          return x;
    accuracy_decimals: 2
    update_interval: 12s  # Reduced frequency to prevent overheating
    state_class: measurement
    expire_after: 2h  # Keep last known value for 2 hours even when device is unavailable
    # Binary sensor updates automatically when distance sensor updates (reads from garage_distance.state)
    timeout: 4.0m
    pulse_time: 10us

  # WiFi signal strength sensor - helps diagnose connection issues in garage
  - platform: wifi_signal
    name: "Garage Door WiFi Signal"
    update_interval: 120s
    entity_category: diagnostic
    unit_of_measurement: "dBm"
    accuracy_decimals: 0

# GPIO Output for relay trigger
output:
  - platform: gpio
    pin: GPIO4
    id: garage_relay_output

# Switch for garage door trigger (appears as button in HA)
switch:
  - platform: template
    id: garage_door_trigger
    name: "Garage Door Trigger"
    icon: "mdi:garage"
    optimistic: true
    turn_on_action:
      - logger.log: "Garage door trigger activated"
      - output.turn_on: garage_relay_output
      - delay: 500ms
      - output.turn_off: garage_relay_output
      - switch.turn_off: garage_door_trigger
      - delay: 2s  # Wait for door to start moving
      - component.update: garage_distance  # Update sensor after trigger (binary sensor updates automatically)

  - platform: template
    name: "Stay Awake Mode"
    id: stay_awake_switch
    optimistic: true
    restore_mode: ALWAYS_ON  # Always start with stay awake mode ON (user can turn off if needed)
    icon: "mdi:power"
    # No availability tracking - switch always available so it can wake device from sleep
    # MQTT commands are handled via on_message subscription below
    turn_on_action:
      - logger.log: "Stay awake mode enabled - device will not sleep"
      - mqtt.publish:
          topic: garage-door-sensor/stay_awake/state
          payload: "ON"
          retain: true
    turn_off_action:
      - logger.log: "Stay awake mode disabled - sending final updates before sleep"
      - component.update: garage_distance  # Force final sensor update before sleep
      - delay: 1s  # Wait for sensor reading
      - mqtt.publish:
          topic: garage-door-sensor/stay_awake/state
          payload: "OFF"
          retain: true
      - delay: 3s  # Give time for MQTT to send all updates (sensor + switch state)
      # Calculate sleep duration to wake at next hour (:00)
      - lambda: |-
          auto time = id(sntp_time).now();
          if (time.is_valid()) {
            int current_minute = time.minute;
            int current_second = time.second;
            // Calculate seconds until next hour
            int seconds_until_hour = (60 - current_minute) * 60 - current_second;
            // Minimum 1 minute, maximum 1 hour
            if (seconds_until_hour < 60) seconds_until_hour = 3600;  // If less than 1 min, sleep until next hour
            if (seconds_until_hour > 3600) seconds_until_hour = 3600;  // Cap at 1 hour
            id(deep_sleep_ctrl).set_sleep_duration(seconds_until_hour * 1000ULL);  // Convert to milliseconds
            ESP_LOGI("deep_sleep", "Sleeping for %d seconds until next hour (:00)", seconds_until_hour);
          } else {
            // If time not synced, use 1 hour default
            id(deep_sleep_ctrl).set_sleep_duration(3600000ULL);
            ESP_LOGI("deep_sleep", "Time not synced - sleeping for 1 hour");
          }
      - logger.log: "Entering deep sleep - will wake at next hour (:00)"
      - deep_sleep.enter: deep_sleep_ctrl

# Binary sensor for garage door open/closed state
binary_sensor:
  - platform: template
    name: "Garage Door Open"
    id: garage_door_open
    # Disable availability tracking - keeps last known state visible when device is unavailable
    availability:
      topic: none
    lambda: |-
      float distance = id(garage_distance).state;
      ESP_LOGD("garage_sensor", "Binary sensor check - Distance: %.3f meters", distance);
      // If distance is invalid (NaN or negative), return last known state
      // This prevents the sensor from showing "unknown" when device is unavailable
      if (isnan(distance) || distance < 0) {
        ESP_LOGD("garage_sensor", "Distance is invalid - keeping last known state");
        // Return false (closed) as default if we can't determine state
        // The availability: topic: none setting will keep this value visible
        return false;  // Default to closed if distance is invalid
      }
      // Door is open if distance > 1.0m, closed if <= 1.0m
      bool is_open = distance > 1.0;
      ESP_LOGD("garage_sensor", "Distance %.3f meters - Door is %s", distance, is_open ? "OPEN" : "CLOSED");
      return is_open;
    filters:
      - delayed_on: 2s  # Reduced delay to prevent false triggers but allow faster updates
      - delayed_off: 2s
    device_class: garage_door
    # Binary sensor updates automatically when distance sensor updates

  - platform: status
    name: "Garage Door Sensor Status"

# Time sync for time-based automation
time:
  - platform: sntp
    id: sntp_time
    timezone: Australia/Melbourne  # Melbourne, Australia timezone
    servers:
      - time.google.com  # Google's reliable NTP servers (most reliable)
      - time.cloudflare.com  # Cloudflare's NTP servers (fast and reliable)
      - 0.au.pool.ntp.org  # Australian NTP pool - closer servers
    on_time_sync:
      - logger.log: "✅ Time synchronized with NTP server"

# Web Server for device access
web_server:
  port: 80
  auth:
    username: admin
    password: !secret ota_password

# WiFi connection health check and time-based sleep automation
interval:
  # WiFi connection health check - monitors connection status and forces reboot if stuck
  # ESPHome automatically attempts reconnection, this monitors and forces reboot if needed
  - interval: 30s  # Check WiFi connection every 30 seconds
    then:
      - if:
          condition:
            lambda: 'return !id(wifi_main).is_connected();'  # WiFi is disconnected
          then:
            - lambda: |-
                id(wifi_disconnected_count)++;
            - logger.log: "WiFi disconnected - ESPHome will attempt automatic reconnection"
            # If disconnected for more than 10 checks (5 minutes), log warning
            # The reboot_timeout (10min) will handle rebooting if connection fails for too long
            - if:
                condition:
                  lambda: 'return id(wifi_disconnected_count) > 10;'  # 5 minutes (10 * 30s)
                then:
                  - logger.log: "⚠️ WiFi disconnected for 5+ minutes - reboot_timeout will reboot if not connected soon"
          else:
            # WiFi is connected - reset counter
            - if:
                condition:
                  lambda: 'return id(wifi_disconnected_count) > 0;'
                then:
                  - lambda: |-
                      id(wifi_disconnected_count) = 0;
                  - logger.log: "✅ WiFi reconnected successfully"

  # Time-based sleep automation: Auto-disable stay awake mode 8pm-8am
  # This allows the device to sleep during night hours (8pm-8am) to reduce heat
  - interval: 1min  # Check time every minute for auto sleep/wake
    then:
      - if:
          condition:
            and:
              - lambda: |-
                  auto time = id(sntp_time).now();
                  if (!time.is_valid()) return false;
                  int hour = time.hour;
                  return (hour >= 20 || hour < 8);  // Night: 8pm-8am
              - lambda: 'return id(stay_awake_switch).state;'  # Currently ON
          then:
            - logger.log: "Night time (8pm-8am) - auto-disabling stay awake mode"
            - switch.turn_off: stay_awake_switch
      - if:
          condition:
            and:
              - lambda: |-
                  auto time = id(sntp_time).now();
                  if (!time.is_valid()) return false;
                  int hour = time.hour;
                  return (hour >= 8 && hour < 20);  // Day: 8am-8pm
              - lambda: 'return !id(stay_awake_switch).state;'  # Currently OFF
          then:
            - logger.log: "Day time (8am-8pm) - auto-enabling stay awake mode"
            - switch.turn_on: stay_awake_switch

  # Periodic updates when awake - only runs if stay awake mode is ON
  # When deep sleep is active, device wakes at the top of each hour (:00) and checks for commands
  - interval: 15s
    then:
      - if:
          condition:
            lambda: 'return id(stay_awake_switch).state;'
          then:
            - logger.log: "Stay awake mode - periodic sensor update"
            # Sensor has its own update_interval: 10s, so it updates automatically
          else:
            - logger.log: "Deep sleep mode - checking for commands then sleeping"
            - component.update: garage_distance  # Force update before sleep
            # Binary sensor updates automatically based on distance reading
            - logger.log: "Waiting for MQTT commands (Stay Awake Mode can be toggled ON now)..."
            - delay: 12s  # Longer window to receive MQTT commands and ensure MQTT update is sent
            # Check if stay_awake_switch was toggled ON during this window
            - if:
                condition:
                  lambda: 'return id(stay_awake_switch).state;'
                then:
                  - logger.log: "✅ Stay awake mode activated via MQTT - staying awake"
                else:
                  # Calculate sleep duration to wake at next hour (:00)
                  - lambda: |-
                      auto time = id(sntp_time).now();
                      if (time.is_valid()) {
                        int current_minute = time.minute;
                        int current_second = time.second;
                        // Calculate seconds until next hour
                        int seconds_until_hour = (60 - current_minute) * 60 - current_second;
                        // Minimum 1 minute, maximum 1 hour
                        if (seconds_until_hour < 60) seconds_until_hour = 3600;  // If less than 1 min, sleep until next hour
                        if (seconds_until_hour > 3600) seconds_until_hour = 3600;  // Cap at 1 hour
                        id(deep_sleep_ctrl).set_sleep_duration(seconds_until_hour * 1000ULL);  // Convert to milliseconds
                        ESP_LOGI("deep_sleep", "Sleeping for %d seconds until next hour (:00)", seconds_until_hour);
                      } else {
                        // If time not synced, use 1 hour default
                        id(deep_sleep_ctrl).set_sleep_duration(3600000ULL);
                        ESP_LOGI("deep_sleep", "Time not synced - sleeping for 1 hour");
                      }
                  - logger.log: "Entering deep sleep - will wake at next hour (:00)"
                  - deep_sleep.enter: deep_sleep_ctrl 